import numpy as np

def gsearch(f, interval, tol):
    a = interval[0]  # Начальная точка интервала
    b = interval[1]  # Конечная точка интервала
    Phi = (1 + np.sqrt(5)) / 2  # Золотое сечение
    L = b - a  # Длина интервала
    x1 = b - L / Phi  # Первая внутренняя точка
    x2 = a + L / Phi  # Вторая внутренняя точка
    y1 = f(x1)  # Значение функции в точке x1
    y2 = f(x2)  # Значение функции в точке x2
    neval = 2  # Количество вычислений функции
    xmin = x1
    fmin = y1

    # Главный цикл
    while np.abs(L) > tol:  # Пока длина интервала больше заданной точности
        if y1 > y2:  # Если значение в x1 больше значения в x2
            a = x1  # Сдвигаем начало интервала
            xmin = x2  # Минимум находится в точке x2
            fmin = y2  # Значение функции в минимуме
            x1 = x2  # Перемещаем x1 на место x2
            y1 = y2  # Значение функции в x1 равно y2
            L = b - a  # Пересчитываем длину интервала
            x2 = a + L / Phi  # Новая внутренняя точка x2
            y2 = f(x2)  # Вычисляем значение функции в новой точке x2
            neval += 1
        else:  # Если значение в x1 меньше или равно значению в x2
            b = x2  # Сдвигаем конец интервала
            xmin = x1  # Минимум находится в точке x1
            fmin = y1  # Значение функции в минимуме
            x2 = x1  # Перемещаем x2 на место x1
            y2 = y1  # Значение функции в x2 равно y1
            L = b - a  # Пересчитываем длину интервала
            x1 = b - L / Phi  # Новая внутренняя точка x1
            y1 = f(x1)  # Вычисляем значение функции в новой точке x1
            neval += 1  # Увеличиваем количество вычислений функции

    answer_ = [xmin, fmin, neval]  # Возвращаем найденный минимум, значение функции в минимуме и количество вычислений
    return answer_  # Возвращаем результат
